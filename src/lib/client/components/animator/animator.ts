/**
 * This code was generated by ChatGPT. It's a reusable, project agnostic animation timeline for JavaScript.
 * It allows scheduling of tweens (value interpolations) and callbacks over a defined duration,
 * making it easy to create complex animations with minimal code.
 *
 * When using with Svelte, you should use the `useAnimator()` hook to get a reactive $state().
 */

/**
 * Easing function type.
 *
 * Takes a normalized time value (0–1) and returns a transformed
 * time value (also 0–1) to produce different easing curves.
 */
export type EasingFn = (t: number) => number;

/** Built-in easing functions */
export const linear: EasingFn = (t) => t;
export const easeInOutQuad: EasingFn = (t) => (t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t);
export const easeOutCubic: EasingFn = (t) => --t * t * t + 1;

/**
 * A tween represents a value interpolation over time.
 */
export interface Tween {
  /** Start time in milliseconds (relative to animator timeline). */
  start: number;

  /** Duration in milliseconds of the tween. */
  duration: number;

  /** Starting value of the property being animated. */
  from: number;

  /** Target value of the property being animated. */
  to: number;

  /** Optional easing function to control the interpolation curve. */
  easing?: EasingFn;

  /**
   * Update function called with the interpolated value
   * each frame while the tween is active.
   */
  update: (value: number) => void;
}

/**
 * A callback scheduled at a specific time in the animation.
 */
export interface Callback {
  /** Time (in ms) at which this callback should fire. */
  at: number;

  /** Function to execute when the time is reached. */
  fn: (time: number) => void;
}

/**
 * Options for creating an Animator instance.
 */
export interface AnimatorOptions {
  /** Total duration of the animation timeline in milliseconds. */
  duration: number;
  loopMode?: 'none' | 'loop' | 'pingpong';
}

/**
 * Animator manages a timeline of tweens and callbacks,
 * driving them forward with requestAnimationFrame.
 */
export class Animator {
  /**
   * Optional listener called each frame with the current time.
   */
  onTick?: (time: number) => void;

  /**
   * Optional listener called when play() is invoked.
   */
  onPlay?: () => void;

  /**
   * Optional listener called when pause() is invoked.
   */
  onPause?: () => void;

  /** Total duration of the timeline (ms). */
  private duration: number;

  /** Looping mode for the animation. */
  private loopMode: 'none' | 'loop' | 'pingpong';

  /** Current direction of playback (1 = forward, -1 = backward). */
  private direction = 1;

  /** Current time position (ms). */
  private time = 0;

  /** Whether the animation is currently playing. */
  private playing = false;

  /** Registered tweens. */
  private tweens: Tween[] = [];

  /** Registered callbacks. */
  private callbacks: Callback[] = [];

  /** ID of the active requestAnimationFrame, if any. */
  private rafId: number | null = null;

  /** Timestamp of the last animation frame. */
  private lastTs = 0;

  /** Timestamp for the callback crossing check */
  private lastTime = 0;

  /**
   * Create a new Animator.
   *
   * @param opts Options including total duration of the timeline.
   */
  constructor(opts: AnimatorOptions) {
    this.duration = opts.duration;
    this.loopMode = opts.loopMode ?? 'none';
  }

  /**
   * Add a tween to the timeline.
   *
   * @param tween Tween definition including start, duration, and update.
   */
  addTween(tween: Tween) {
    this.tweens.push(tween);
  }

  /**
   * Remove a tween from the timeline.
   *
   * @param tween The tween to remove.
   */
  removeTween(tween: Tween) {
    this.tweens = this.tweens.filter((t) => t !== tween);
  }

  /**
   * Add a callback to fire at a specific time.
   *
   * @param cb Callback definition.
   */
  addCallback(cb: Callback) {
    this.callbacks.push(cb);
  }

  /**
   * Remove a callback from the timeline.
   *
   * @param cb The callback to remove.
   */
  removeCallback(cb: Callback) {
    this.callbacks = this.callbacks.filter((c) => c !== cb);
  }

  /**
   * Clear all tweens and callbacks from the timeline.
   */
  clear() {
    this.tweens = [];
    this.callbacks = [];
  }

  /**
   * Start playing the timeline from the current position.
   * Does nothing if already playing.
   */
  play() {
    if (this.playing) return;
    this.playing = true;
    this.lastTs = performance.now();
    this.loop();
    this.onPlay?.();
  }

  /**
   * Pause playback. Keeps the current timeline position.
   */
  pause() {
    this.playing = false;
    if (this.rafId !== null) cancelAnimationFrame(this.rafId);
    this.onPause?.();
  }

  /**
   * Seek to an exact time (ms) in the timeline.
   *
   * @param ms The new time to jump to.
   */
  seek(ms: number) {
    this.time = Math.max(0, Math.min(ms, this.duration));
    this.applyTweens();
  }

  /**
   * Step the timeline forward (or backward) by a delta in ms.
   *
   * @param delta Time delta to advance (can be negative).
   */
  step(delta: number) {
    const oldTime = this.time;

    this.time += delta * this.direction;

    if (this.loopMode === 'none') {
      this.time = Math.max(0, Math.min(this.time, this.duration));
    } else if (this.loopMode === 'loop') {
      if (this.time > this.duration) this.time %= this.duration;
      if (this.time < 0) this.time = ((this.time % this.duration) + this.duration) % this.duration;
    } else if (this.loopMode === 'pingpong') {
      if (this.time > this.duration) {
        this.time = this.duration - (this.time - this.duration);
        this.direction = -1;
      } else if (this.time < 0) {
        this.time = -this.time;
        this.direction = 1;
      }
    }

    this.applyTweens();
    this.applyCallbacks(oldTime, this.time);
    this.onTick?.(this.time);
  }

  /**
   * Restart the timeline from the beginning and play.
   */
  restart() {
    this.time = 0;
    this.direction = 1;
    this.applyTweens();
    this.play();
  }

  /**
   * Get the current time position (ms).
   */
  getTime() {
    return this.time;
  }

  /**
   * Whether the timeline is currently playing.
   */
  isPlaying() {
    return this.playing;
  }

  /**
   * Internal loop driven by requestAnimationFrame.
   * Calculates delta time and steps the timeline.
   */
  private loop = () => {
    if (!this.playing) return;
    const now = performance.now();
    const delta = now - this.lastTs;
    this.lastTs = now;
    this.step(delta);
    this.rafId = requestAnimationFrame(this.loop);
  };

  /**
   * Apply tween values and trigger callbacks based on the current time.
   */
  private applyTweens() {
    for (const t of this.tweens) {
      if (this.time >= t.start && this.time <= t.start + t.duration) {
        // Tween is active
        const localT = (this.time - t.start) / t.duration;
        const eased = t.easing ? t.easing(localT) : localT;
        const val = t.from + (t.to - t.from) * eased;
        t.update(val);
      } else if (this.time > t.start + t.duration) {
        // Past the tween → clamp to `to`
        t.update(t.to);
      } else if (this.time < t.start) {
        // Before the tween → clamp to `from`
        t.update(t.from);
      }
    }

    for (const c of this.callbacks) {
      // Fire if we're within one frame (~16ms) of the target time
      if (Math.abs(this.time - c.at) < 16) c.fn(this.time);
    }
  }

  private applyCallbacks(prevTime: number, currentTime: number) {
    for (const c of this.callbacks) {
      if (prevTime <= c.at && currentTime >= c.at) {
        c.fn(c.at);
      }
      if (prevTime >= c.at && currentTime <= c.at && this.direction < 0) {
        c.fn(c.at);
      }
    }
    this.lastTime = this.time;
  }
}
